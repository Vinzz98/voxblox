<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>voxblox: voxblox::io Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="jquery.js"></script>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevoxblox.html">voxblox</a></li><li class="navelem"><a class="el" href="namespacevoxblox_1_1io.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">voxblox::io Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvoxblox_1_1io_1_1PlyWriter.html">PlyWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a mesh to a .ply file.  <a href="classvoxblox_1_1io_1_1PlyWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a01ebe8d82a1813ccc4874a6c9c7c1b37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37">PlyOutputTypes</a> { <a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37a7e27b97e8420dbccae1e91353ac490c1">kSdfColoredDistanceField</a>, 
<a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37a90f0643a29e52e2282fd2c0019984c3c">kSdfIsosurface</a>, 
<a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37ae1bc0d6e79c44b8483b0692d9b0ce0df">kSdfIsosurfaceConnected</a>
 }</td></tr>
<tr class="separator:a01ebe8d82a1813ccc4874a6c9c7c1b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a99b2a500d9e764d536f7d06f4437cdd8"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a99b2a500d9e764d536f7d06f4437cdd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a99b2a500d9e764d536f7d06f4437cdd8">convertLayerToMesh</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const <a class="el" href="structvoxblox_1_1MeshIntegratorConfig.html">MeshIntegratorConfig</a> &amp;mesh_config, <a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *mesh, const bool connected_mesh=true, const <a class="el" href="namespacevoxblox.html#a69a49f8f7c4d44b7d31daab36e4bc7dc">FloatingPoint</a> vertex_proximity_threshold=1e-10)</td></tr>
<tr class="memdesc:a99b2a500d9e764d536f7d06f4437cdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the layer to a mesh by extracting its ISO surface using marching cubes.  <a href="#a99b2a500d9e764d536f7d06f4437cdd8">More...</a><br /></td></tr>
<tr class="separator:a99b2a500d9e764d536f7d06f4437cdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501daa1d8f0289ff3fd28b2cb056875e"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a501daa1d8f0289ff3fd28b2cb056875e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a501daa1d8f0289ff3fd28b2cb056875e">convertLayerToMesh</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, <a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *mesh, const bool connected_mesh=true, const <a class="el" href="namespacevoxblox.html#a69a49f8f7c4d44b7d31daab36e4bc7dc">FloatingPoint</a> vertex_proximity_threshold=1e-10)</td></tr>
<tr class="separator:a501daa1d8f0289ff3fd28b2cb056875e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d0568927343a09374c70ab4b2bb462"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ab7d0568927343a09374c70ab4b2bb462"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#ab7d0568927343a09374c70ab4b2bb462">convertVoxelGridToPointCloud</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const float sdf_color_range, const float sdf_max_value, <a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *point_cloud)</td></tr>
<tr class="memdesc:ab7d0568927343a09374c70ab4b2bb462"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts all voxels with positive weight/observed into points colored by a color map based on the SDF value.  <a href="#ab7d0568927343a09374c70ab4b2bb462">More...</a><br /></td></tr>
<tr class="separator:ab7d0568927343a09374c70ab4b2bb462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660181da1e9ed768c455c2d366c83dcb"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a660181da1e9ed768c455c2d366c83dcb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a660181da1e9ed768c455c2d366c83dcb">convertVoxelGridToPointCloud</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const float sdf_color_range, <a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *point_cloud)</td></tr>
<tr class="separator:a660181da1e9ed768c455c2d366c83dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810bf4da8ac151407c9f24336ede73ce"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a810bf4da8ac151407c9f24336ede73ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a810bf4da8ac151407c9f24336ede73ce">getColorFromVoxel</a> (const VoxelType &amp;voxel, const float sdf_color_range, const float sdf_max_value, <a class="el" href="structvoxblox_1_1Color.html">Color</a> *color)</td></tr>
<tr class="memdesc:a810bf4da8ac151407c9f24336ede73ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a voxel to a colored point.  <a href="#a810bf4da8ac151407c9f24336ede73ce">More...</a><br /></td></tr>
<tr class="separator:a810bf4da8ac151407c9f24336ede73ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d26be7f867be63b0a28fbb38fdac917"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0d26be7f867be63b0a28fbb38fdac917"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a0d26be7f867be63b0a28fbb38fdac917">getColorFromVoxel</a> (const <a class="el" href="structvoxblox_1_1TsdfVoxel.html">TsdfVoxel</a> &amp;voxel, const float sdf_color_range, const float sdf_max_value, <a class="el" href="structvoxblox_1_1Color.html">Color</a> *color)</td></tr>
<tr class="memdesc:a0d26be7f867be63b0a28fbb38fdac917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a voxel to a colored point.  <a href="#a0d26be7f867be63b0a28fbb38fdac917">More...</a><br /></td></tr>
<tr class="separator:a0d26be7f867be63b0a28fbb38fdac917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612186d47d97b45ea17e17e191683d7e"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a612186d47d97b45ea17e17e191683d7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a612186d47d97b45ea17e17e191683d7e">getColorFromVoxel</a> (const <a class="el" href="structvoxblox_1_1EsdfVoxel.html">EsdfVoxel</a> &amp;voxel, const float sdf_color_range, const float sdf_max_value, <a class="el" href="structvoxblox_1_1Color.html">Color</a> *color)</td></tr>
<tr class="memdesc:a612186d47d97b45ea17e17e191683d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a voxel to a colored point.  <a href="#a612186d47d97b45ea17e17e191683d7e">More...</a><br /></td></tr>
<tr class="separator:a612186d47d97b45ea17e17e191683d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bc498fe69573d9775dc73d636b9544"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ae2bc498fe69573d9775dc73d636b9544"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#ae2bc498fe69573d9775dc73d636b9544">LoadBlocksFromFile</a> (const std::string &amp;file_path, typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::BlockMergingStrategy strategy, <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; *layer_ptr)</td></tr>
<tr class="memdesc:ae2bc498fe69573d9775dc73d636b9544"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, loads blocks without multiple layer support.  <a href="#ae2bc498fe69573d9775dc73d636b9544">More...</a><br /></td></tr>
<tr class="separator:ae2bc498fe69573d9775dc73d636b9544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cd3ed6a797eb896555cb0bb318a4b0"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a99cd3ed6a797eb896555cb0bb318a4b0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a99cd3ed6a797eb896555cb0bb318a4b0">LoadBlocksFromFile</a> (const std::string &amp;file_path, typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::BlockMergingStrategy strategy, bool multiple_layer_support, <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; *layer_ptr)</td></tr>
<tr class="memdesc:a99cd3ed6a797eb896555cb0bb318a4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, loads blocks without multiple layer support.  <a href="#a99cd3ed6a797eb896555cb0bb318a4b0">More...</a><br /></td></tr>
<tr class="separator:a99cd3ed6a797eb896555cb0bb318a4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f05073e94b0699caefe03976244bf72"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a8f05073e94b0699caefe03976244bf72"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a8f05073e94b0699caefe03976244bf72">LoadLayer</a> (const std::string &amp;file_path, typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::Ptr *layer_ptr)</td></tr>
<tr class="memdesc:a8f05073e94b0699caefe03976244bf72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike LoadBlocks, this actually allocates the layer as well.  <a href="#a8f05073e94b0699caefe03976244bf72">More...</a><br /></td></tr>
<tr class="separator:a8f05073e94b0699caefe03976244bf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a032bfb82e52e8e7faac2930b8b8e37"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a9a032bfb82e52e8e7faac2930b8b8e37"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a9a032bfb82e52e8e7faac2930b8b8e37">LoadLayer</a> (const std::string &amp;file_path, const bool multiple_layer_support, typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::Ptr *layer_ptr)</td></tr>
<tr class="memdesc:a9a032bfb82e52e8e7faac2930b8b8e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlike LoadBlocks, this actually allocates the layer as well.  <a href="#a9a032bfb82e52e8e7faac2930b8b8e37">More...</a><br /></td></tr>
<tr class="separator:a9a032bfb82e52e8e7faac2930b8b8e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d1194b1e481f97ffba45435f386467"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:af4d1194b1e481f97ffba45435f386467"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#af4d1194b1e481f97ffba45435f386467">outputLayerAsPly</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const std::string &amp;filename, <a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37">PlyOutputTypes</a> type, const float sdf_color_range=0.3f, const float max_sdf_value_to_output=0.3f)</td></tr>
<tr class="memdesc:af4d1194b1e481f97ffba45435f386467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the layer to ply file.  <a href="#af4d1194b1e481f97ffba45435f386467">More...</a><br /></td></tr>
<tr class="separator:af4d1194b1e481f97ffba45435f386467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f237c4a29346ecc2235c1c320d5c6b"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:ad2f237c4a29346ecc2235c1c320d5c6b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#ad2f237c4a29346ecc2235c1c320d5c6b">SaveLayer</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const std::string &amp;file_path, bool clear_file=true)</td></tr>
<tr class="memdesc:ad2f237c4a29346ecc2235c1c320d5c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, clears (truncates) the output file.  <a href="#ad2f237c4a29346ecc2235c1c320d5c6b">More...</a><br /></td></tr>
<tr class="separator:ad2f237c4a29346ecc2235c1c320d5c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c977c42b1b0960af7e6099d1714803"><td class="memTemplParams" colspan="2">template&lt;typename VoxelType &gt; </td></tr>
<tr class="memitem:a63c977c42b1b0960af7e6099d1714803"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevoxblox_1_1io.html#a63c977c42b1b0960af7e6099d1714803">SaveLayerSubset</a> (const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;layer, const std::string &amp;file_path, const <a class="el" href="namespacevoxblox.html#ab6a2a9c55d969e553791db1f7472a8f3">BlockIndexList</a> &amp;blocks_to_include, bool include_all_blocks)</td></tr>
<tr class="memdesc:a63c977c42b1b0960af7e6099d1714803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves only some parts of the layer to the file. Clears the file by default.  <a href="#a63c977c42b1b0960af7e6099d1714803">More...</a><br /></td></tr>
<tr class="separator:a63c977c42b1b0960af7e6099d1714803"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a01ebe8d82a1813ccc4874a6c9c7c1b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ebe8d82a1813ccc4874a6c9c7c1b37">&#9670;&nbsp;</a></span>PlyOutputTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37">voxblox::io::PlyOutputTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a01ebe8d82a1813ccc4874a6c9c7c1b37a7e27b97e8420dbccae1e91353ac490c1"></a>kSdfColoredDistanceField&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a01ebe8d82a1813ccc4874a6c9c7c1b37a90f0643a29e52e2282fd2c0019984c3c"></a>kSdfIsosurface&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a01ebe8d82a1813ccc4874a6c9c7c1b37ae1bc0d6e79c44b8483b0692d9b0ce0df"></a>kSdfIsosurfaceConnected&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00017">17</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a99b2a500d9e764d536f7d06f4437cdd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b2a500d9e764d536f7d06f4437cdd8">&#9670;&nbsp;</a></span>convertLayerToMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::convertLayerToMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvoxblox_1_1MeshIntegratorConfig.html">MeshIntegratorConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>connected_mesh</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevoxblox.html#a69a49f8f7c4d44b7d31daab36e4bc7dc">FloatingPoint</a>&#160;</td>
          <td class="paramname"><em>vertex_proximity_threshold</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the layer to a mesh by extracting its ISO surface using marching cubes. </p>
<p>This function returns false if the mesh is empty. The mesh can either be extracted as a set of distinct triangles, or the function can try to connect all identical vertices to create a connected mesh. </p>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00127">127</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<a id="a501daa1d8f0289ff3fd28b2cb056875e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501daa1d8f0289ff3fd28b2cb056875e">&#9670;&nbsp;</a></span>convertLayerToMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::convertLayerToMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>connected_mesh</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevoxblox.html#a69a49f8f7c4d44b7d31daab36e4bc7dc">FloatingPoint</a>&#160;</td>
          <td class="paramname"><em>vertex_proximity_threshold</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00151">151</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<a id="ab7d0568927343a09374c70ab4b2bb462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d0568927343a09374c70ab4b2bb462">&#9670;&nbsp;</a></span>convertVoxelGridToPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::convertVoxelGridToPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *&#160;</td>
          <td class="paramname"><em>point_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts all voxels with positive weight/observed into points colored by a color map based on the SDF value. </p>
<p>The parameter sdf_color_range is used to determine the range of the rainbow color map which is used to visualize the SDF values. If an SDF value is outside this range, it will be truncated to the limits of the range. sdf_max_value determines if a point is generated for this value or not. Only SDF values within this max value result in a colored point. If this threshold is set to a negative value, all points will be generated independent of the SDF value. </p>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00071">71</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<a id="a660181da1e9ed768c455c2d366c83dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660181da1e9ed768c455c2d366c83dcb">&#9670;&nbsp;</a></span>convertVoxelGridToPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::convertVoxelGridToPointCloud </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Mesh.html">voxblox::Mesh</a> *&#160;</td>
          <td class="paramname"><em>point_cloud</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00112">112</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<a id="a810bf4da8ac151407c9f24336ede73ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810bf4da8ac151407c9f24336ede73ce">&#9670;&nbsp;</a></span>getColorFromVoxel() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::getColorFromVoxel </td>
          <td>(</td>
          <td class="paramtype">const VoxelType &amp;&#160;</td>
          <td class="paramname"><em>voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Color.html">Color</a> *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a voxel to a colored point. </p>
<p>The sdf_color_range determines the range that is covered by the rainbow colors. All absolute distance values that exceed this range will receive tha max/min color of the rainbow range. The sdf_max_value determines if a point is generated for this value or not. Only SDF values within this max value result in a colored point. </p>

</div>
</div>
<a id="a0d26be7f867be63b0a28fbb38fdac917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d26be7f867be63b0a28fbb38fdac917">&#9670;&nbsp;</a></span>getColorFromVoxel() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::getColorFromVoxel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvoxblox_1_1TsdfVoxel.html">TsdfVoxel</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Color.html">Color</a> *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a voxel to a colored point. </p>
<p>The sdf_color_range determines the range that is covered by the rainbow colors. All absolute distance values that exceed this range will receive tha max/min color of the rainbow range. The sdf_max_value determines if a point is generated for this value or not. Only SDF values within this max value result in a colored point. </p>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8cc_source.html#l00010">10</a> of file <a class="el" href="sdf__ply_8cc_source.html">sdf_ply.cc</a>.</p>

</div>
</div>
<a id="a612186d47d97b45ea17e17e191683d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612186d47d97b45ea17e17e191683d7e">&#9670;&nbsp;</a></span>getColorFromVoxel() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::getColorFromVoxel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvoxblox_1_1EsdfVoxel.html">EsdfVoxel</a> &amp;&#160;</td>
          <td class="paramname"><em>voxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvoxblox_1_1Color.html">Color</a> *&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a voxel to a colored point. </p>
<p>The sdf_color_range determines the range that is covered by the rainbow colors. All absolute distance values that exceed this range will receive tha max/min color of the rainbow range. The sdf_max_value determines if a point is generated for this value or not. Only SDF values within this max value result in a colored point. </p>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8cc_source.html#l00038">38</a> of file <a class="el" href="sdf__ply_8cc_source.html">sdf_ply.cc</a>.</p>

</div>
</div>
<a id="ae2bc498fe69573d9775dc73d636b9544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bc498fe69573d9775dc73d636b9544">&#9670;&nbsp;</a></span>LoadBlocksFromFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::LoadBlocksFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::BlockMergingStrategy&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; *&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, loads blocks without multiple layer support. </p>
<p>Loading blocks assumes that the layer is already setup and allocated. </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00104">104</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
<a id="a99cd3ed6a797eb896555cb0bb318a4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd3ed6a797eb896555cb0bb318a4b0">&#9670;&nbsp;</a></span>LoadBlocksFromFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::LoadBlocksFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::BlockMergingStrategy&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multiple_layer_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; *&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, loads blocks without multiple layer support. </p>
<p>Loading the full layer allocates a layer of the correct size. </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00015">15</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
<a id="a8f05073e94b0699caefe03976244bf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f05073e94b0699caefe03976244bf72">&#9670;&nbsp;</a></span>LoadLayer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::LoadLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::Ptr *&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlike LoadBlocks, this actually allocates the layer as well. </p>
<p>By default loads without multiple layer support (i.e., only checks the first layer in the file). </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00216">216</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
<a id="a9a032bfb82e52e8e7faac2930b8b8e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a032bfb82e52e8e7faac2930b8b8e37">&#9670;&nbsp;</a></span>LoadLayer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::LoadLayer </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>multiple_layer_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt;::Ptr *&#160;</td>
          <td class="paramname"><em>layer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlike LoadBlocks, this actually allocates the layer as well. </p>
<p>By default loads without multiple layer support (i.e., only checks the first layer in the file). </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00114">114</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
<a id="af4d1194b1e481f97ffba45435f386467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d1194b1e481f97ffba45435f386467">&#9670;&nbsp;</a></span>outputLayerAsPly()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::outputLayerAsPly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevoxblox_1_1io.html#a01ebe8d82a1813ccc4874a6c9c7c1b37">PlyOutputTypes</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>sdf_color_range</em> = <code>0.3f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>max_sdf_value_to_output</em> = <code>0.3f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the layer to ply file. </p>
<p>Depending on the ply output type, this either exports all voxel centers colored by th SDF values or extracts the ISO surface as mesh. The parameter sdf_color_range is used to color the points for modes that use an SDF-based point cloud coloring function. </p>

<p class="definition">Definition at line <a class="el" href="sdf__ply_8h_source.html#l00167">167</a> of file <a class="el" href="sdf__ply_8h_source.html">sdf_ply.h</a>.</p>

</div>
</div>
<a id="ad2f237c4a29346ecc2235c1c320d5c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f237c4a29346ecc2235c1c320d5c6b">&#9670;&nbsp;</a></span>SaveLayer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::SaveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear_file</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, clears (truncates) the output file. </p>
<p>Set clear_file to false in case writing the second (or subsequent) layer into the same file. </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00223">223</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
<a id="a63c977c42b1b0960af7e6099d1714803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c977c42b1b0960af7e6099d1714803">&#9670;&nbsp;</a></span>SaveLayerSubset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VoxelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool voxblox::io::SaveLayerSubset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoxblox_1_1Layer.html">Layer</a>&lt; VoxelType &gt; &amp;&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevoxblox.html#ab6a2a9c55d969e553791db1f7472a8f3">BlockIndexList</a> &amp;&#160;</td>
          <td class="paramname"><em>blocks_to_include</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_all_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves only some parts of the layer to the file. Clears the file by default. </p>

<p class="definition">Definition at line <a class="el" href="layer__io__inl_8h_source.html#l00230">230</a> of file <a class="el" href="layer__io__inl_8h_source.html">layer_io_inl.h</a>.</p>

</div>
</div>
</div><!-- contents -->

<br clear="all" />
<hr size="1"><div style="align: right;">
<a href="http://wiki.ros.org/voxblox">voxblox</a><br />
Author(s): Helen Oleynikova <helen.oleynikova@mavt.ethz.ch>, Marius Fehr <marius.fehr@mavt.ethz.ch></br />
<small>autogenerated on Tue Nov 13 2018 09:18:52</small>
</div>
</body>
</html>
